#+IMPORTANT: -*- mode: org -*-
#+title: Benjamin Hansen's Portfolio
#+language: en
#+options: H:4 num:nil toc:nil \n:nil @:t ::t |:t ^:t *:t TeX:t LaTeX:t
#+options: html-postamble:nil
#+startup: showeverything entitiespretty
#+setupfile: theme-bigblow.setup

* Publish                                                          :noexport:

#+begin_src elisp :results silent
  (require 'git) ; for git commands  
  (defun commit-and-push-to-repo (&optional file-to-commit commit-message)
    (setq commit-message (or commit-message "New upload."))
    (setq file-to-commit (or file-to-commit "docs/index.html"))
    (let ((git-repo "."))
      (git-add file-to-commit)
      (git-commit commit-message file-to-commit)
      (git-fetch "origin")
      (git-push "origin" "master")))
#+end_src
#+begin_src elisp :results silent
  (defun commit-and-push-all (&optional commit-message)
    (setq commit-message (or commit-message "New Upload."))
    (let ((git-repo "."))
      (copy-file "../Resumes/BenjaminRHansenResume.pdf" "docs/BenjaminRHansenResume.pdf" t)
      (git-add "docs/index.html" "docs/BenjaminRHansenResume.pdf" "index.txt")
      (git-commit commit-message "docs/index.html" "docs/BenjaminRHansenResume.pdf" "index.txt")
      (git-fetch "origin")
      (git-push "origin" "master")))
#+end_src
#+begin_src elisp
  (commit-and-push-all)
#+end_src

#+results:
: To github.com:benjaminrhansen/Portfolio.git
:    3f1dca6..9bf8a64  master -> master

** Links

  [[elisp:(browse-url-of-file (org-html-export-to-html))][Export to HTML and Browse]]
  Save first
  [[elisp:(org-html-export-to-html)][Export to HTML]]
  [[elisp:(rename-file "index.html" "docs/" t)][Move to docs]]
  [[elisp:(copy-file%20"../Resumes/BenjaminRHansenResume.pdf"%20"docs/"%20t)][Copy Resume PDF to docs]]
  [[elisp:(commit-and-push-all)][Commit & Push All Possible New Files]]

  [[https://benjaminrhansen.github.io/Portfolio/]]

* TODO About
  [[file:linkedinprofilecircle.png][file:./linkedinprofilecircle.png]]
*** TODO Self Introduction
  Hi! I'm Benjamin Hansen. I am from Southern Utah. I became interested in computer science in high school where I took 5 computer courses. I went on a mission for my church, [[https://churchofjesuschrist.org][The Church of Jesus Christ of Latter-day Saints]], worked construction for 4 months, and then started my Bachelor's of Science in Computer Science at [[https://www.byui.edu/][Brigham Young University - Idaho]]. I chose Computer Science because I found I liked from my web design and development course and programming course in high school. What really brought me confidence that I could do well in this field was from acheiving the highest grade on the final exam of my programming class.

  Ever since, programming paradigms and concepts have come easily to me. I can quickly learn languages and write programs in them. What I really love is Erlang. I feel like Erlang is almost as easy as Python. My initial solution to a problem is not hard to implement in Erlang, whereas in other languages it may take many revisions to my initial solution to solve the problem. I've created many modules with many functions in Erlang, for a class and on my free time. I prefer doing mathematical alogirhtms and functions in Erlang. I love its scalability and simplicity.

  I've also used my C++ knowledge in 5 semesters of courses. After learning Python during my Machine Learning course, I learned R within a short span of time to do the final project. I feel confident I can learn any software and accomplish any task given to me.

** TODO External Links
| [[https://linkedin.com/in/benjaminrhansen][LinkedIn Profile]]  | [[file:BenjaminRHansenResume.pdf][Resume]] | [[https://github.com/benjaminrhansen][GitHub Profile]]  |



** TODO References
*** TODO Lee Barney
*** TODO John Batty
*** TODO Others...
* TODO Side Projects
** TODO Automation of Summer Workflow
** TODO Hangman.app
* TODO Class Projects
** TODO Project Manager for Team of 3, Bit-by-Bit
** TODO Discrete Mathematics
** TODO Mathematica for a Physics Project
** TODO Machine Learning Data Manipulation, Emotion
** TODO Back Pain Reading Times
*** TODO Design the Study
*** TODO Collect the Data
*** TODO Describe the Data
*** TODO Make Inference
*** TODO Take Action
** TODO Team Lead for Team of 5 in Class-wide Project
* TODO Research
** TODO Research & Creative Works Conference
** TODO Fractional Library
** TODO Multithreading: How many threads? - White Paper
   In my Operating Systems class, our final project was a research paper on how many threads are needed for a given program to maximize performance.

   Here is the file for the white paper:
   file:./WhitePaper.pdf
* TODO Graduation Plans
*** TODO July 2021
*** TODO Internship
*** TODO Senior Project
* Blog
** <2020-07-24 Fri>
*** Debugging
Today I was doing quick coding in JavaScript, working on my Summer side project you can view here: [[https://benjaminrhansen.github.io/Portfolio/#outline-container-org4ad206c][Automate Summer Workflow]].
It was all going fairly well until I created a whole block of code I understood logically would work (or should, because it made
since to me) but it didn't. It would work on the first loop, and then not on any of the others. I was so confused. I displayed some
outputs, pondered what might be affecting the error given the message I was receiving. I made some minor changes, and still - the same bug prevailed.

So, I had to get in to the nitty-gritty and *comment every single line*. After commenting thoroughly each little
piece of the block, I got down to almost the last little bit without any idea what might have been wrong and found the bug.
I thought, what is this doing here? How did it still run once and then quit. It was very weird. After deleting that extra unneeded stuff, it worked.
*** TODO Code Snippet before
#+begin_src js
  // keep prompting for the desired order until the reamainingGoals array is
  // empty
  const todaysOrderedGoals =
        until(
            ([remainingGoals,_p,_t]) => remainingGoals.length == 0,
                ([remainingGoals, priority, todaysOrderedGoals]) => {
                const nextPrioritizedGoal =
                      untilSubmission(function() {
                          return app.chooseFromList(remainingGoals.map(Goal => Goal["goal"]), {
                              withTitle: "It's Your Choice",
                              withPrompt: "Prioritize the next goal for your calendar:",
                              defaultItems: [remainingGoals[0]["goal"]],
                              multipleSelectionsAllowed: false,
                              emptySelectionAllowed: false,
                              okButtonName: "Prioritize",
                              cancelButtonName: "Retry"
                          });
                      },chooseFromListRetry)[0];
                const Goal = remainingGoals.find(Goal => Goal["goal"] === nextPrioritizedGoal);
                Goal["priority"] = priority; // change the Goal's priority to the current priority accumulator
                app.displayDialog(JSON.stringify(Goal));
                todaysOrderedGoals.push(Goal);
                app.displayDialog(JSON.stringify(todaysOrderedGoals));
                return [remainingGoals.filter(Goal => Goal["goal"] !== nextPrioritizedGoal),
                        priority + 1,
                        todaysOrderedGoals];
            }, [todaysGoals, 1, []])[2];
#+end_src
*** TODO Code Snippet after
#+begin_src js
  // keep prompting for the desired order until the reamainingGoals array is
  // empty
  // not the most efficient way. Too many mappings, one for each iteration....
  // loop until the reaminingGoals length == 0, then we have no more elements so we should stop
  // looping
  const todaysOrderedGoals =
        until(
            // the condition function to call on each iteration
            // takes in the accumulator and returns true/false
            // destructuring-bind the 3-element list of the remainingGals, the priority which we don't care about, as well as the todaysOrderedGoals which we also don't care about
            // This function receives one argument and calls length on the remaining goals
            ([remainingGoals,_p,_t]) => remainingGoals.length == 0, // is the length of the goals array zero?
            // the main function to call on each iteration. Takes in an acumulator and returns the next value for the accumulator
            // descturing-bind the 3-element list for remainingGoals, priority, and ordered goal list we are building
            // define the function as...
                ([remainingGoals, priority, todaysOrderedGoals]) => {
                // for debugging purposes
                //app.displayDialog("Going in: ".concat(JSON.stringify(remainingGoals)));
                // get the next prioritized goal (a string of the goal name)
                const nextPrioritizedGoal =
                      // until submission will return a list of goals
                      // since only one item will be in the list, like we want, choose the first
                      // goal
                      // loop until the submission is complete (the user didn't hit "retry"
                      untilSubmission(function() {
                          // we must return or else undefined will be returned for this function
                          // call the chooseFromList function like we usually do
                          // redundantly map the remainingGoals list to be a list of strings each iteration
                          return app.chooseFromList(remainingGoals.map(Goal => Goal["goal"]), {
                              // the title for the dialog
                              withTitle: "It's Your Choice",
                              // the prompt for the dialog
                              withPrompt: "Prioritize the next goal for your calendar:",
                              // the default selected item should be the first goal of the remainingGoals list
                              defaultItems: [remainingGoals[0]["goal"]],
                              // we shouldn't be allowed to select more than one element
                              multipleSelectionsAllowed: false,
                              // selecting no elements is not allowed
                              emptySelectionAllowed: false,
                              // make the okay button say this
                              okButtonName: "Prioritize",
                              // make the cancel button say this
                              cancelButtonName: "Retry"
                          });
                          // give the untilSubmission function the chooseFromListRetry function which
                          // returns true if the result was false (meaning the user "cancelled" the dialog)
                      },chooseFromListRetry)[0]; // get the goal out of the single-element list
                // get the goal from the remaining goals list that matches the user's desired prioritized goal
                // used find without any extra optional parameters
                // give it a simple function which takes in a Goal parameter (object) and see's if the goal's
                // name is equal to the nextPrioritizedGoal. If so, return that object!
                const Goal = remainingGoals.find(Goal => Goal["goal"] === nextPrioritizedGoal);
                // set priority and push into array
                Goal["priority"] = priority; // change the Goal's priority to the current priority accumulator
                app.displayDialog(JSON.stringify(Goal));
                todaysOrderedGoals.push(Goal); // push the goal into the ordered goals array of objects
                app.displayDialog(JSON.stringify(todaysOrderedGoals));
                // return the list for the accumulator
                // increment the priority
                // this confusing logic filters the remaining goals list for the goals that are not
                // the goal the user wants to prioritize
                return [remainingGoals.filter(Goal => Goal["goal"] !== nextPrioritizedGoal),
                        // increment the priority accumulator
                        priority + 1,
                        // keep track of our building up of the goals array
                        todaysOrderedGoals];
                // end of main function for until. For the initial value of the accumulator,
                // give todaysGoals list with the first goal as priority one and the empty list to build the ordered goals from
            }, [todaysGoals, 1, []])[2]; // return from the until returned list the third item, the ordered goals!
#+end_src
